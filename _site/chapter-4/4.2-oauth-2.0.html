<!DOCTYPE html>
<html lang="en">
<head>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:site" content="@kehers">
  <meta name="twitter:title" content="4.2. OAuth 2.0">
  <meta name="twitter:description" content="OAuth 2.01 is the second evolution of the OAuth protocol. It has a couple of advantages over the first version.


  OAuth 2 is simpler and easier. The steps are reduced and there are no complex sig...">
  <meta name="twitter:creator" content="@kehers">
  <title>4.2. OAuth 2.0</title>
  <link href='https://fonts.googleapis.com/css?family=Libre+Baskerville:400,700' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" href="/assets/css/normalize.css">
  <link rel="stylesheet" href="/assets/css/skeleton.css">
  <link rel="stylesheet" href="/assets/css/custom.css">
  <link rel="stylesheet" href="/assets/css/zenburn.css" />
</head>
<body>

<div class="container">
  <header>
    <div class="row">
      <div id="logo" class="three columns">
        <div id="menu">☰</div>
      </div>
    </div>
  </header>
  <div class="row">
    <div class="six offset-by-three columns">
      <article>
        <h5>Chapter 4</h5>
        <h1 class="title">4.2. OAuth 2.0</h1>
        <p>OAuth 2.0<sup id="fnref:1"><a href="#fn:1" class="footnote">1</a></sup> is the second evolution of the OAuth protocol. It has a couple of advantages over the first version.</p>

<ol>
  <li>OAuth 2 is simpler and easier. The steps are reduced and there are no complex signing process. Not using signatures to validate requests has however been an argument against OAuth 2. This is considered to be less secure. OAuth 2 relies on the use of SSL to ensure tokens are securely sent. (The specification strongly recommends all provider endpoints to be on SSL).</li>
  <li>OAuth 2 scales better. With OAuth 1, a lot of resources can go into state management and signature validation for every request at the provider end.</li>
  <li>There is better support for non-browser based applications. Remember, with OAuth 1 the user is redirected to the authorization URL (in a browser) and is redirected back to the consumer’s callback URL on authorization (still within the browser). This makes it hard<sup id="fnref:2"><a href="#fn:2" class="footnote">2</a></sup> for non-browser clients, desktop clients as one, to be able to implement OAuth 1. OAuth 2 solves this by providing different <strong>grant types</strong> for different use cases.</li>
</ol>

<p>OAuth 2.0 generally involves two steps.</p>

<ol>
  <li>The user is redirected to the provider for an authorization code</li>
  <li>The consumer exchanges the code for an access token</li>
</ol>

<p>Unlike OAuth 1 however, the process differs according to the grant type. In step 2, the provider MAY also issue a <strong>refresh token</strong>. Refresh tokens are used to obtain new access tokens when the current one expires or becomes invalid.</p>

<p>Let’s look at the grant types and the process for each. Don’t forget that the OAuth registration comes first and the consumer gets a client id and secret.</p>

<p>The available grant types are:</p>

<ol>
  <li>Authorization Code</li>
  <li>Implicit</li>
  <li>[Resource Owner] Password Credentials</li>
  <li>Client Credentials</li>
</ol>

<p>Providers may support one or more of the grant types. Authorization Code and Implicit grant types are the most supported ones.</p>

<h5 id="authorization-code">1. Authorization Code</h5>

<p>This is used by browser-based consumers that can handle browser redirects and can keep their client id and secret confidential.</p>

<p>The first step is that the consumer redirects the user to the authorization endpoint with the following parameters (as supported and documented by the provider):</p>

<ol>
  <li><code class="highlighter-rouge">response_type</code> - value must be <strong>code</strong></li>
  <li><code class="highlighter-rouge">client_id</code></li>
  <li><code class="highlighter-rouge">redirect_uri</code> - this is the callback URL the user will be redirected from the authorization URL. Optional.</li>
  <li><code class="highlighter-rouge">scope</code> - the scope of authorization. This defines what the consumer is requesting access to? Photos? Likes? Followers? The available scopes will be provided by the provider. This is different from OAuth 1. In OAuth 1, the scope is specified during the application registration process: In OAuth 2, the client specifies the required scope during the authorization request.</li>
  <li><code class="highlighter-rouge">state</code> - a value the consumer sends to the provider and expects to be sent back to the redirect url. The consumer uses this to maintain states between the request and callback to prevent unauthorized request by a third-party disguising as the consumer. The consumer checks this when the user is redirected back to be sure it matches what was sent initially. This helps ensure the callback redirection is not from the wrong source. The parameter is optional but recommended.</li>
</ol>

<p>Here is a sample authorization URL with the parameters:</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">https://api.instagram.com/oauth/authorize/?client_id={CLIENT_ID}&amp;redirect_uri={REDIRECT_URI}&amp;response_type=code&amp;scope={SCOPE}&amp;state={STATE}</code></pre></figure>

<p>The authorization URL presents the user an authorization page where the user gets to allow or deny access the consumer access.</p>

<p>The user is then redirected back to the <strong>redirect_uri</strong> with an authorization code, if he chooses to allow, or an error if he denies.</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">https://redirect-uri?code={CODE}&amp;state={STATE}</code></pre></figure>

<p>The second step is to request the access token with the code. These are the parameters used for the next access token request.</p>

<ol>
  <li><code class="highlighter-rouge">grant_type</code> - Value must be <strong>authorization_code</strong></li>
  <li><code class="highlighter-rouge">code</code> - Code received from authorization</li>
  <li><code class="highlighter-rouge">client_id</code></li>
  <li><code class="highlighter-rouge">client_secret</code></li>
  <li><code class="highlighter-rouge">redirect_uri</code> - This is the callback URL the user will be redirected from the authorization URL. Optional.</li>
</ol>

<figure class="highlight"><pre><code class="language-text" data-lang="text">POST /oauth/access_token
Host: api.instagram.com
Content-Type: application/x-www-form-urlencoded

grant_type=authorization_code&amp;code={CODE}&amp;redirect_uri={REDIRECT_URI}&amp;client_id={CLIENT_ID}&amp;client_secret={CLIENT_SECRET}</code></pre></figure>

<p>The provider in turn replies with the access token in a response body similar to this:</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">{"access_token":"2YotnFZFEjr1zCsicMWpAA"}</code></pre></figure>

<h5 id="implicit">2. Implicit</h5>

<p>In the authorization code grant type above, the client secret is posted with other parameters to obtain the access token. But remember, the client secret must be kept confidential so this is only feasible in server side consumers that can make POST request in a way the user can’t see, unlike pure client-side (e.g. javascript) consumers. The implicit grant type allows pure client-side consumers request access token without sending their client secret. The way it works is that the user is  redirected to the authorization URL as is in the authorization grant type; just that this time, the <code class="highlighter-rouge">response_type</code> parameter will have the value <strong>token</strong></p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">https://instagram.com/oauth/authorize/?client_id={CLIENT-ID}&amp;redirect_uri={REDIRECT-URI}&amp;response_type=token</code></pre></figure>

<p>The provider returns the access token directly and not an authorization code this time around. So the step where the authorization code is exchanged for access token and the client secret is sent with other parameters is completely out of the flow.</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">https://redirect-uri#access_token={ACCESS_TOKEN}</code></pre></figure>

<h5 id="password-credentials">3. Password Credentials</h5>

<p>This grant type allows the consumer exchange the user’s username and password for an access token directly. It is recommended to be used for consumers that are highly trusted by the provider only. Or apps created by the provider itself.</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">POST /oauth/token
Host: api.provider-site.com
Content-Type: application/x-www-form-urlencoded

grant_type=password&amp;username={USERNAME}&amp;password={PASSWORD}&amp;client_id={CLIENT_ID}</code></pre></figure>

<h5 id="client-credentials">4. Client Credentials</h5>

<p>Here, the consumer can directly exchange the client id and secret for an access token.</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">POST /oauth/token
Host: api.provider-site.com
Content-Type: application/x-www-form-urlencoded

grant_type=client_credentials&amp;client_id={CLIENT_ID}&amp;client_secret={CLIENT_SECRET}</code></pre></figure>

<p>-</p>

<h4 id="making-authenticated-requests">Making authenticated requests</h4>

<p>Once the consumer has the access token, it can now be used to request resources that require authorization. This can be done by passing the access token through the Authorization header, POST body parameter or URI query parameter of a GET request. These are the same methods used in OAuth 1.0.</p>

<p>The format of the Authorization header is:</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">Authorization: Bearer access_token</code></pre></figure>

<p>Here is an example of using the Authorization header:</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">GET /me
HOST: graph.facebook.com
Authorization: Bearer PhJTNqTdQb2</code></pre></figure>

<p>Although not specified on the Instagram developer site, Instagram does not support using Authorization headers. The other methods work. Here is an example of using URI query parameter to request a user profile:</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">GET /v1/users/1574083/?access_token=51624076.f59def8.eee28c2fb41f4b07b0
HOST: api.instagram.com</code></pre></figure>

<div class="footnotes">
  <ol>
    <li id="fn:1">
      <p>RFC 6749: <a href="http://tools.ietf.org/html/rfc6749">http://tools.ietf.org/html/rfc6749</a> <a href="#fnref:1" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:2">
      <p>Some providers have workarounds for this. An example is Twitter’s PIN-Based OAuth (<a href="https://dev.twitter.com/oauth/pin-based">https://dev.twitter.com/oauth/pin-based</a>) <a href="#fnref:2" class="reversefootnote">&#8617;</a></p>
    </li>
  </ol>
</div>

      </article>
    </div>
  </div>
</div>
<div class="colophon">
  <div class="container">
    <div class="row">
      <div class="six offset-by-three columns">
        <ul class="pagination">
        
        
        <li class="six columns m-t-20 prev"><a href="/chapter-4/4.1-oauth-1.0.html">4.1. OAuth 1.0</a></li>
        <li class="six columns m-t-20 next"></li>
        </ul>

      </div>
    </div>
  </div>
</div>

<footer>
  <div class="container">
    <div class="row">
      <div class="six offset-by-three columns">
        <nav>
          <li><a href="/">home</a></li>
          <li><a href="http://gum.co/Sxoj" class="bordered">Download the book. Free</a></li>
        </nav>
        <p>&copy; 2016. Opeyemi Obembe. All rights reserved.</p>
      </div>
    </div>
  </div>
</footer>

<script type="text/javascript" src="/assets/js/menu.js"></script>
<script src="https://carnivalapp.io/sites/502/init.js"></script>
<script>
  document.addEventListener("DOMContentLoaded", Carnival.init);
</script>

</body>
</html>

